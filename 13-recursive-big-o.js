// Take your solutions from the recursive exercises that you completed in the previous checkpoint and identify the time complexities (big O) of each of them.

// Counting Sheep
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input. 
// So counting 30 sheep takes less time than 100 sheep.

// Power Calculator
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input.
// The recursive function gets called everytime you decrease the exponent, which you have to do all the way down to 1.
// So the larger the exponent, the more times we need to recursivly call the function

// Reverse String
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input. 
// The recursive function gets called everytime you 

// nth Triangular Number
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input. 

// String Spliter
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input. 

// Fibonacci
// Exponential Time (O(2^n)) has running times that grow rapidly with any increase in input size.

// Factorial
// Linear Time (O(n)) has running times that are directly proportional to the size (n) of the input. 

// Maze One Path
// Polynomial Time (O(n^k)) has a running time that would be some input size n raised to some constant power k.

// Maze All Paths
// Exponential Time (O(2^n)) has running times that grow rapidly with any increase in input size.

// Anagrams
// Polynomial Time (O(n^k)) has a running time that would be some input size n raised to some constant power k.

// Organization Chart


// Binary Representation
// Logarithmic Time (O(log(n))) takes longer with larger inputs, but running time increases slowly. Cuts the problem size in half each round. 